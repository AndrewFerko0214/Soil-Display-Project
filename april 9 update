# -*- coding: utf-8 -*-
"""
Created on Tue Apr  9 19:32:45 2019

@author: SFU
"""

def Node_Selection(i,j,Node,h,k,qx,qy,deltax,deltay):
   # Material change only works for inside boundaries
    if Node ==0:
        h_n = (h[i+1,j] +h[i-1,j] + h[i,j+1]+ h[i,j-1])/4
   

    # Bottom Boundary no flux
    elif Node == 10:
        h_n = (h[i+1,j] + h[i-1,j] + 2*h[i,j+1])/4
    
    # Top Boundary no flux
    elif Node == 20:
        h_n = (h[i+1,j] + h[i-1,j] + 2*h[i,j-1])/4
    
    
    # Left Boundary no flux
    elif Node == 30:
      h_n = (h[i,j+1] + h[i,j-1]+ 2*h[i+1,j])/4
        
       # Right Boundary no flux 
    elif Node == 40:
        h_n = (h[i,j+1] + h[i,j-1]+ 2*h[i-1,j])/4
    
    
    #Interior Corner no flux
    elif Node == 50:
        h_n = (2*h[i+1,j]+ 2*h[i,j+1])/4
    
    
    # Exterior bottom right corner no flux 4 different
    elif Node == 60:
        h_n = 2*h[i-1,j] + 2*h[i,j+1]
        
    # Exterior corner bottom left no flux
    elif Node == 70:
        h_n = 2*h[i+1,j]+2*h[i,j+1]
        
    #Exterior top right corner no flux
    elif Node == 80:
        h_n = 2*h[i-1,j] + 2*h[i,j-1]
        
    
    #Exterior top left corner
    elif Node == 90:
        h_n = 2*h[i+1,j] + 2*h[i,j-1]
    
    
    # Bottom Boundary material change Inside domain
    elif Node == 13:
        h_barT = (k[i,j+1]*h[i,j+1] + k[i,j-1]*h[i,j-1])/(k[i,j+1] + k[i,j-1])
        h_n = (2*h_barT + h[i,j+1] + h[i,j-1])/4
    
    
    
    # Left Boundary material change inside domain
    elif Node == 33:
        h_bar_sides = (k[i+1,j]*h[i+1,j] + k[i-1,j]*h[i-1,j])/(k[i+1,j]+k[i-1,j])
        h_n = (2*h_bar_sides + h[i+1,j] + h[i-1,j])/4
    
    
    #Left boundary fixed flux
    elif Node == 31:
        h_n = (2*h[i+1,j] - 2*deltax*(qx/-k[i,j]) + h[i,j+1] + h[i,j-1])/4
   
     #Top Boundary fixed flux
    elif Node == 21:
        h_n =  (2*h[i,j-1] - 2*deltay*(qy/-k[i,j]) + h[i+1,j] + h[i-1,j])/4
    
    
    #Bottom Boundary fixed Flux
    elif Node == 11:
        h_n = (2*h[i,j+1] - 2*deltay*(qy/-k[i,j]) + h[i+1,j] + h[i-1,j])/4
    
    
    
    # Right Boundary fixed flux
    elif Node == 41:
        h_n = (2*h[i-1,j] - 2*deltax*(qx/-k[i,j]) + h[i,j+1] + h[i,j-1])/4
   
    
  
    
   #Bottom Boundary constant head
    elif Node == 12:
        h_n = h[i,j]
    
    
    #Top Boundary constant head
    elif Node == 22:
        h_n= h[i,j]
    
    
    #Left Boundary constant head
    elif Node == 32:
        h_n = h[i,j]
    
    
    #Right Boundary constant head
    elif Node == 42:
        h_n = h[i,j]
        
    
    #Interior corner constant head
    elif Node == 52:
        h_n = h[i,j]

    # Exterior corner constant head
    elif Node == 62:
        h_n = h[i,j]
    
    ## Bandstras code for hydraulic conductivity for project
    elif Node == 444:
        h_n =(2*(k[i-1,j]*h[i-1,j] + k[i+1,j]*h[i+1,j])/(k[i-1,j]+h[i+1,j]) + 2*(k[i,j+1]*h[i,j+1]+k[i,j-1]*h[i,j-1])/(k[i,j+1]+h[i,j-1]))/4
    return h_n



import numpy as np
from numba import jit
import matplotlib.pyplot as plt

@jit
def GaussSiedel_NoLowerFlux(T,Node,tol):
    err = tol + 1
    iters = 0
    lam = 1.5
    Nx, Ny = np.shape(T)
    while err > tol:
        err = 0
        iters += 1
        for j in range(0,Ny):
            for i in range(0,Nx):
#                print(i)
                T_o = T[i,j]
                # nearest neighbor avg assumes dx = dy
                T_n = Node_Selection(i,j,Node[i,j],h,k,qx,qy,deltax,deltay)
                # over relaxation
                T_n = lam*T_n + (1-lam)*T_o
                err = max(err, abs(T_o - T_n))
                T[i,j] = T_n
    return T, iters


import pandas as pd
data = pd.read_excel(r'C:\Users\SFU\Documents\junior year spring\Mod and Sim\user_interface11.xlsx', sheetname='user')
L = np.transpose(np.array(data))
Nx,Ny = np.shape(L)
Inputs = pd.read_excel(r'C:\Users\SFU\Documents\junior year spring\Mod and Sim\user_interface11.xlsx', sheetname='flux')
Inputs1 = np.transpose(np.array(Inputs))
qx1 = Inputs1[0,:]
qy1 = Inputs1[1,:]
K1 = Inputs1[2,:]
K2 = Inputs1[3,:]
K3 = Inputs1[4,:]


k = np.zeros_like(L,dtype = 'float')
#for i in range(0,Nx):
 #   for j in range(0,Ny):
  #      k[8*[i]:8*[i+1], 8*[j]:8*[j+1]] = L[i,j]



for j in range(0,Ny):
    for i in range(0,Nx):
        if L[i,j] == 1:
            k[i,j] = K1
        if L[i,j] == 2:
            k[i,j] = K2
        if L[i,j] == 3:
            k[i,j] = K3


N = np.zeros_like((L), dtype=int)
h = np.ones_like(N, dtype='float')*5
qy = np.ones_like(N) *qy1
qx = np.ones_like(N) * qx1


#boundaries and internal nodes
N[0,:] = 32
N[-1,:] = 42
N[:,0] = 20
N[:,-1] = 10
N[1:-1,1:-1] = 444
# water influent and effluent points on left and right
#left
N[0,1] = 31
N[0,2] = 31
N[0,3] = 31
N[0,4] = 31
N[0,7] = 31
N[0,10] = 31
N[0, 12] = 31
#right
N[-1,1] = 41
N[-1,2] = 41
N[-1,3] = 41
N[-1,4] = 41
N[-1,7] = 41
N[-1,10] = 41
N[-1, 12] = 41






#your_matrix = pd.get_array(r'C:\Users\SFU\Documents\junior year spring\Mod and Sim\user_interface11.xlsx')

data = pd.read_excel(r'C:\Users\SFU\Documents\junior year spring\Mod and Sim\user_interface11.xlsx')

#df = pd.DataFrame(data, columns= ['Price'])

#print(df)
