


def Node_Selection(i,j,Node,h,k,qx,qy,deltax,deltay):
   # Material change only works for inside boundaries
   
    
    
    if Node ==0:
        h_n = (h[i+1,j] +h[i-1,j] + h[i,j+1]+ h[i,j-1])/4
   

    # Bottom Boundary no flux
    elif Node == 10:
        h_n = (h[i+1,j] + h[i-1,j] + 2*h[i,j+1])/4
    
    # Top Boundary no flux
    elif Node == 20:
        h_n = (h[i+1,j] + h[i-1,j] + 2*h[i,j-1])/4
    
    
    # Left Boundary no flux
    elif Node == 30:
      h_n = (h[i,j+1] + h[i,j-1]+ 2*h[i+1,j])/4
        
       # Right Boundary no flux 
    elif Node == 40:
        h_n = (h[i,j+1] + h[i,j-1]+ 2*h[i-1,j])/4
    
    
    #Interior Corner no flux
    elif Node == 50:
        h_n = (2*h[i+1,j]+ 2*h[i,j+1])/4
    
    
    # Exterior bottom right corner no flux 4 different
    elif Node == 60:
        h_n = 2*h[i-1,j] + 2*h[i,j+1]
        
    # Exterior corner bottom left no flux
    elif Node == 70:
        h_n = 2*h[i+1,j]+2*h[i,j+1]
        
    #Exterior top right corner no flux
    elif Node == 80:
        h_n = 2*h[i-1,j] + 2*h[i,j-1]
        
    
    #Exterior top left corner
    elif Node == 90:
        h_n = 2*h[i+1,j] + 2*h[i,j-1]
    
    
    # Bottom Boundary material change Inside domain
    elif Node == 13:
        h_barT = (k[i,j+1]*h[i,j+1] + k[i,j-1]*h[i,j-1])/(k[i,j+1] + k[i,j-1])
        h_n = (2*h_barT + h[i,j+1] + h[i,j-1])/4
    
    
    
    # Left Boundary material change inside domain
    elif Node == 33:
        h_bar_sides = (k[i+1,j]*h[i+1,j] + k[i-1,j]*h[i-1,j])/(k[i+1,j]+k[i-1,j])
        h_n = (2*h_bar_sides + h[i+1,j] + h[i-1,j])/4
    
    
    #Left boundary fixed flux
    elif Node == 31:
        h_n = (2*h[i+1,j] - 2*deltax*(qx/-k[i,j]) + h[i,j+1] + h[i,j-1])/4
   
     #Top Boundary fixed flux
    elif Node == 21:
        h_n =  (2*h[i,j-1] - 2*deltay*(qy/-k[i,j]) + h[i+1,j] + h[i-1,j])/4
    
    
    #Bottom Boundary fixed Flux
    elif Node == 11:
        h_n = (2*h[i,j+1] - 2*deltay*(qy/-k[i,j]) + h[i+1,j] + h[i-1,j])/4
    
    
    
    # Right Boundary fixed flux
    elif Node == 41:
        h_n = (2*h[i-1,j] - 2*deltax*(qx/-k[i,j]) + h[i,j+1] + h[i,j-1])/4
   
    
  
    
   #Bottom Boundary constant head
    elif Node == 12:
        h_n = h[i,j]
    
    
    #Top Boundary constant head
    elif Node == 22:
        h_n= h[i,j]
    
    
    #Left Boundary constant head
    elif Node == 32:
        h_n = h[i,j]
    
    
    #Right Boundary constant head
    elif Node == 42:
        h_n = h[i,j]
        
    
    #Interior corner constant head
    elif Node == 52:
        h_n = h[i,j]

    # Exterior corner constant head
    elif Node == 62:
        h_n = h[i,j]
    
    
    
    
    return h_n










import numpy as np
from numba import jit
import matplotlib.pyplot as plt

@jit
def GaussSiedel_NoLowerFlux(T,Node,tol):
    err = tol + 1
    iters = 0
    lam = 1.5
    Nx, Ny = np.shape(T)
    while err > tol:
        err = 0
        iters += 1
        for j in range(0,Ny):
            for i in range(0,Nx):
#                print(i)
                T_o = T[i,j]
                # nearest neighbor avg assumes dx = dy
                T_n = Node_Selection(i,j,Node[i,j],h,k,qx,qy,deltax,deltay)
                # over relaxation
                T_n = lam*T_n + (1-lam)*T_o
                err = max(err, abs(T_o - T_n))
                T[i,j] = T_n
    return T, iters













import pandas as pd



your_matrix = pe.get_array(r'C:\Users\SFU\Documents\Mod and Sim\User_Interface.xlsx')

#data = pd.read_excel(r'C:\Users\SFU\Documents\Mod and Sim\User_Interface.xlsx')
#print(data)

#df = pd.DataFrame(data, columns= ['Price'])

#print(df)
