
def Node_Selection(i,j,Node,h,Kx,Ky):
   
    h_bar_sides = (k[i+1,j]*h[i+1,j] + k[i-1,j]*h[i-1,j])/k[i+1,j]+k[i-1,j]
    h_barT = (k[i,j+1]*h[i,j+1] + k[i,j-1]*h[i,j-1])/k[i,j+1] + k[i,j-1]
    # Bottom Boundary no flux
    if Node == 10:
        h_n = (h[i+1,j] + h[i-1,j] + 2*h[i,j+1])/4
    
    
    # Top Boundary no flux
    elif Node == 20:
        h_n = (h[i+1,j] + h[i-1,j] + 2*h[i,j-1])/4
    
    
    # Left Boundary no flux
    elif Node == 30:
        h_n = (h[i,j+1] + h[i,j-1]+ 2*h[i+1,j])/4
    
    
    # Right Boundary no flux
    elif Node == 40:
        h_n = (h[i,j+1] + h[i,j-1]+ 2*h[i-1,j])/4
    
    
    #Interior Corner no flux
    elif Node == 50:
        h_n = (2*h[i+1,j]+ 2*h[i,j+1])/4
    
    
    # Exterior corner no flux
    elif Node == 60:
        h_n = ()
    
    
    # Bottom Boundary fixed flux
    elif Node == 11:
        h_n = (2*h_barT + h[i,j+1] + h[i,j-1])/4
    
    
    # Top Boundary fixed flux
    elif Node == 21:
        h_n = ()
    
    
    # Left Boundary fixed flux
    elif Node == 31:
        h_n = (2*h_bar_sides + h[i+1,j] + h[i,j-1])/4
    
    
    # Right Boundary fixed flux
    elif Node == 41:
        h_n = ()
   
    
    #Interior corner fixed flux
    elif Node == 51:
        h_n = ()
    
    
  # Exterior Corner fixed flux
    elif Node == 61:
        h_n = ()
  
    
   #Bottom Boundary constant head
    elif Node == 12:
        h_n = h[i,j]
    
    
    #Top Boundary constant head
    elif Node == 22:
        h_n= h[i,j]
    
    
    #Left Boundary constant head
    elif Node == 32:
        h_n = h[i,j]
    
    
    #Right Boundary constant head
    elif Node == 42:
        h_n = h[i,j]
        
    
    #Interior corner constant head
    elif Node == 52:
        h_n = h[i,j]

    # Exterior corner constant head
    elif Node == 62:
        h_n = h[i,j]
    
    h_n = h[i,j]
    
    
    
    `return h_out



import numpy as np
from numba import jit
import matplotlib.pyplot as plt

@jit
def GaussSiedel_NoLowerFlux(T, tol):
    err = tol + 1
    iters = 0
    lam = 1.5
    Nx, Ny = np.shape(T)
    while err > tol:
        err = 0
        iters += 1
        for i in range(0,Nx):
            T[i,0] = T[i,1] 
        for j in range(1, Ny-1):
            for i in range(1, Nx-1):
                T_o = T[i,j]
                # nearest neighbor avg assumes dx = dy
                T_n = Node_Selection(i,j,Node,h)
                # over relaxation
                T_n = lam*T_n + (1-lam)*T_o
                err = max(err, abs(T_o - T_n))
                T[i,j] = T_n
    return T, iters
